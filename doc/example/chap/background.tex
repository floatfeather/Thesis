\chapter{研究背景}

\section{缺陷定位例子}

\section{使用基于频谱的缺陷定位}

\section{使用基于状态覆盖的缺陷定位}

比如，对于如下代码C代码，
\lstset{language=C}
\begin{lstlisting}
a = abs(a);
if (update_b) {
    b = sqrt(a);
}
\end{lstlisting}
当\mycode{a}和\mycode{b}的类型都为\mycode{int}时，如果\mycode{a}的值为最小的\mycode{int}时（\mycode{a = -2147483648}），
则代码会在第3行出错（\mycode{b}的值为\mycode{NAN}）。
这是因为当\mycode{a = -2147483648}时，第1行的\mycode{a}会被赋值为一个负数，于是在第3行进行\mycode{sqrt}操作的时候，就被出错。
在第1行的时候，考虑两个抽象的状态\mycode{a $\ge$ 0}和\mycode{a $<$ 0}。
发现通过的测试只有\mycode{a $\ge$ 0}这个状态，而失败的测试只有\mycode{a $<$ 0}这个状态。
所以可以认为\mycode{a $<$ 0}是缺陷状态，引入这个状态的第1行的语句很可能就是缺陷语句。